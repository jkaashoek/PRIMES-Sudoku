\section{Case Studies}

\subsection{Sudoku}

\subsubsection{Declarative Definition}
We use the python frontend of the z3 constraint solver in combination with list comprehension to specify the 9x9
sudoku puzzle declaratively. As can be noticed from the encoding, it
can be easily generalized to other sudoku sizes, such as 16x16 or
25x25.

We first define 81 different integer variables (\t{X[0][0], X[0][1], \ldots,
X[8][8]}), where \t{X[i][j]} denotes the value of the sudoku cell (i, j). We
also define the valid set of values each element can take: 1 $\leq$
\t{X[i][j]} $\leq$ 9 (valid values).

\singlespace
\begin{lstlisting}[language=python, frame = single]
X = [[Int('x%d%d' % (i,j)) for i in range(9)] for j in range(9)]
valid_values = [And ( X[i][j] >= 1, X[i][j] <= 9) for i in range(9)
for j in range(9)]
\end{lstlisting}
\doublespace

We now add the sudoku constraints that the values in each row should be
distinct (\t{rows\textunderscore distinct}), values in each column should be distinct
(\t{cols\textunderscore distinct}), and that values each 3x3 square should be distinct
(\t{three\textunderscore by\textunderscore three\textunderscore distinct}).

\singlespace
\begin{lstlisting}[language=python, frame = single]
row_distinct = [Distinct(X[i]) for i in range(9)]
cols_distinct = [Distinct([X[i][j] for i in range(9)]) for j in
range(9)] 
three_by_three_distinct = [ Distinct([X[3*k + i][3*l + j] for i in
range(3) for j in range(3)]) for k in range(3) for l in range(3)]

\end{lstlisting}
\doublespace

To encode partially filled sudoku board (where a 0 value denotes an
empty space), we simply add the constraint \t{X[i][j] == board[i][j]} when
\t{board[i][j]} != 0. 

\singlespace
\begin{lstlisting}[language=python, frame = single]
 already_set = [X[i][j] == board[i][j] if board[i][j] != 0 for i in
 range(9) for j in range(9)]

\end{lstlisting}
\doublespace

The complete set of constraints sudoku constraint is obtained by
combining all previous constraints:

\singlespace
\begin{lstlisting}[language=python, frame = single]
sudoku_constraint = valid_values + row_distinct + cols_distinct +
three_by_three_distinct + already_set
\end{lstlisting}
\doublespace


\subsubsection{Creating the Initial Puzzle}
To accomplish this, we use a set of equations using the python z3 constraint solver. This would generate a sudoku board in a 2 dimensional list such as the one
below. 
\t{
\singlespace
\begin{center}
[[4, 9, 7, 1, 8, 2, 5, 3, 6] \newline
[1, 5, 2, 3, 6, 4, 8, 9, 7] \newline
[8, 6, 3, 5, 7, 9, 4, 1, 2] \newline
[7, 3, 4, 6, 9, 1, 2, 5, 8] \newline
[2, 8, 9, 4, 3, 5, 7, 6, 1] \newline
[5, 1, 6, 7, 2, 8, 9, 4, 3] \newline
[3, 2, 5, 9, 1, 7, 6, 8, 4] \newline
[9, 7, 1, 8, 4, 6, 3, 2, 5] \newline
[6, 4, 8, 2, 5, 3, 1, 7, 9]] \newline
\end{center}}
\doublespace

\subsubsection{Emptying Squares}

The next step is to start removing values from the board. Our method for
selecting the next square to remove includes the following
sub-steps:

\begin{enumerate}
\item {\bf Select a square to empty in a probabilistic fashion.} For
  row $N$, we calculate the percentage of cells that have not been
  removed, $P_N$. We then randomly select a row $i$, where $0 \le i
  \le 8$, and generate a random number between 0 and 1. If this number
  is less than $P_i$, then we keep $i$ as our selected row. If this
  number is greater than $P_i$, then we discard $i$ and select a new
  random row and calculate a new decimal between 0 and 1. Once we have
  a number between 0 and 1 that is less than the percentage calculated
  we keep this row. We then follow the same process to find which
  column $j$ in the row we should empty. The final selected square
  will be at the intersection of the selected row and column, at
  $(i,j)$. The complete process allows for rows with more un-emptied
  cells to have a greater chance of being chosen.
\item {\bf Temporarily set the selected square as emptied.} We create a temporary board and a new set of z3 constraints with the changed value.
\item{\bf Check whether the temporary board is valid.} If the temporary board has fewer than K solutions, we keep the board. Otherwise, the selected square is added to \t{vals\_tried}, the list of squares that do not work, and we repeat steps 1 - 3 until we have a valid selected square.
\item{\bf Permanently remove a valid square.}
\item{\bf Repeat steps 1 through 4} until the target number of emptied squares is reached or the sum of the number of squares in \t{vals\_tried} and the number that are already emptied reaches 81. 
\end{enumerate}

\subsubsection{Transformations}


\singlespace
\begin{table}
\begin{tabularx}{\textwidth}{|X|X|}
\hline
\multicolumn{2}{|c|}{Table 1: Symmetrical Transformations}\\
\hline
9x9 Sudoku Board & 12x12 Sudoku Board
\\
\hline
\begin{enumerate}
\item Relabeling the nine digits
\item Permuting the three 3x9 stacks
\item Permuting the three 9x3 bands
\item Permuting the three rows within a stack
\item Permuting the three columns within a band
\item Reflecting about the axes of symmetry in a square
\item Rotation by 90 degrees
\end{enumerate} &

\begin{enumerate}
\item Relabeling the twelve digits
\item Permuting the four 3x12 stacks
\item Permuting the three 12x4 bands
\item Permuting the three rows within a stack
\item Permuting the four columns within a band
\item Reflecting about the horizontal and vertical axes in a square
\end{enumerate}
 \\
\hline
\end{tabularx}
\end{table}

\doublespace

We are able to quickly generate more full sudoku boards for emptying
without using SAT solvers. To do this, we repeatedly apply mathematically symmetrical transformations to an already-created sudoku board. Out of about $6 \times 10^{21}$ total unique 9x9 sudoku boards, these transformations can generate about $3\times 10^6$ new unique sudoku boards from an existing one. [source] Furthermore, we can apply most or all of these transformations to larger boards. Table 1 shows the symmetrical transformations that can be applied to 9x9 and 12x12 boards.

As the last step of our generation algorithm, we perform these transformations again on an already emptied board to generate more emptied puzzles that possibly have a different number of solutions.


\subsubsection{Defining Complexity}
After a sudoku puzzle is generated, we determine its difficulty using
machine learning. For each puzzle, a 15-component vector is generated to describe the unsolved board. These components are (1) number of solutions; (2) number of empty squares; (3) number of rows with at least seven blank squares; (4) number of columns with at least seven blank squares; (5) number of 3x3 grids with at least seven blank squares; (6 - 14) number of occurrences of each digit; (15) standard deviation of number of occurrences of each digit from the mean number of occurrences.

The SVM library by scikit-learn then uses the vector to categorize the
puzzle into one of four difficulties: (1) Easy, (2) Medium, (3) Hard,
and (4) Evil.

\subsection{Fillomino}

\subsubsection{Declarative Definition}
Using the python frontend on z3, we can declaratively create a fillomino puzzle.
First, we define an NxN board and assert that only the values between
1 and N can be on the board: 

\singlespace
\begin{lstlisting}[language=python, frame=single]
cells = [[Int("x%d%d" % (i,j)) for i in range(1,N+1)] for j in
         range(1,N+1)]
valid_cells = [And(cells[i][j] <= N, cells[i][j] >=1) for i in
	range(N) for j in range(N)]
\end{lstlisting}
\doublespace

Now we must assert the definition of a fillomino puzzle; that the
value of all of the squares in a specified region must be the same as
the number of squares in that region. We do this using graphs, with
each vertex being a cell on a board and each edge being some type of relationship between the cells.

We define each \t{edge\_val} to be a directed edge between a cell and one of its adjacent cells. If \t{edge\_val == 1}, there exists an outgoing edge from that cell to an adjacent square, and if \t{edge\_val == 0}, there exists no such edge. We constrain it so that outgoing edges exist only between two cells that are in the same region. 

\singlespace
\begin{lstlisting}[language=python, frame=single]
for i in range(N):
    for j in range(N):
        for (k,l) in getAdjacent1(i,j):
            edge_var[(i,j,k,l)] = Int("e%d%d%d%d" % (i,j,k,l))
edge_val_constraints = [Or(edge_val==0,edge_val==1) for edge_val in
    edge_var.values()]
\end{lstlisting}
\doublespace

In our construction of the directed graph, there can be at most one outgoing edge from every square, meaning that the sum of all \t{edge\_val} for a cell will always be less than or equal to 1.

\singlespace
\begin{lstlisting}[language=python, frame=single]
for i in range(N):
   for j in range(N):
      for (k,l) in getAdjacent1(i,j, N):
         if lessThan(i,j,k,l):
            sum_edges = edge_var[(i,j,k,l)] + edge_var[(k,l,i,j)]
                 edge_val_constraints.append(sum_edges <= 1)
\end{lstlisting}
\doublespace

If there is an edge between two cells, those two cells are in the same regions; therefore, they should have the same value.

\singlespace
\begin{lstlisting}[language=python, frame=single]
same_value_constraint = []
for i in range(N):
    for j in range(N):
        for (k,l) in getAdjacent1(i,j, N):
            if lessThan(i,j,k,l):
               same_value_constraint.append(Implies(Or(
               edge_var[(i,j,k,l)]==1,  edge_var[(k,l,i,j)]==1), 
               cells[i][j] == cells[k][l]))
\end{lstlisting}
\doublespace

Next, we create a new variable for each cell, \t{in\_cell}, that is equal to
the number of directed edges from neighboring cells going into the cell.

\singlespace
\begin{lstlisting}[language=python, frame=single]
in_cell = [[Int("in%d%d"%(i,j)) for i in range(N)] for j in range(N)]
in_cell_constraints=[]
for i in range(N):
   for j in range(N):
      in_cell_constraints.append(And(in_cell[i][j]>=0,
      in_cell[i][j]<=1))
      sum_incoming_edges = Sum([edge_var[(k,l,i,j)] for (k,l) in
      getAdjacent1(i,j, N)])
      in_cell_constraints.append(in_cell[i][j]==sum_incoming_edges)
\end{lstlisting}
\doublespace

Finally, we define a cell size as being the sum of the sizes of the
adjacent cells + 1 as the constraint solver iterates over all cells. In each region, we add the constraint such that there is exactly one cell with a size equal to its value. 

\singlespace
\begin{lstlisting}[language=python, frame=single]
size_region_constraint=[]
size_cell = [[ Int("size%d%d" % (i,j)) for i in range(N)] for j in
                            range(N)]
    size_region_constraint=[And(size_cell[i][j] >=1,
    size_cell[i][j]<=N) for i in range(N) for j in range(N)]

    for i in range(N):
        for j in range(N):
            size_adjacent = Sum([If(edge_var[(i,j,k,l)]==1,
            size_cell[k][l],0) for (k,l) in getAdjacent1(i,j, N)])
            size_region_constraint.append(size_cell[i][j] ==
            (size_adjacent+1))
            size_region_constraint.append(Implies(in_cell[i][j]==0,
            size_cell[i][j] == cells[i][j]))
\end{lstlisting}
\doublespace


\subsubsection{Creating the Initial Puzzle}
We have two ways of creating the initial full board. We generate a full board with z3 using the declarative definition of a fillomino puzzle, but this code is slow and not random. Our second option is to create a board using python only. The python code works by selecting a starting square, randomly selecting a sequence length from a list of
valid sequence lengths, and then setting a list of squares that are sequence length long that all have the value sequence length. We continue like this until the board is completely filled.


\subsubsection{Emptying Squares}

We adapt our emptying algorithm for fillomino.

\begin{enumerate}
\item {\bf Select a square to empty.} Choose a square from a region
  that has more than one cell that is not emptied. Unlike in sudoku, we do not check probabilistically for squares in rows, columns, or three by three grids that have more un-emptied squares because the only constraint in fillomino is that there must be at least one value in every region that is not emptied.
\item {\bf Temporarily set the selected square as emptied, check whether the temporary board is valid, and permanently remove a valid square.} These steps are the exact same as steps 2 - 4 of sudoku emptying.
\item{\bf Repeat steps 1 and 2} until the target number of emptied squares is reached or the sum of the number of squares in \t{vals\_tried} and the number that are already emptied reaches $N^2$. 
\end{enumerate}

\subsubsection{Transformations}
Because of the randomness of the different regions, there are less
transformations that can be applied to fillomino than sudoku, but a
number still exist. These are (1) Rotation, (2) Vertical reflection, and (3) Horizontal reflection. These transformations be applied to an emptied board to get 7 new fillomino boards with different orientations form the original one.

\subsubsection{Defining Complexity}
Using machine learning, we determine the difficulty of an unsolved
fillomino puzzle based on its 4-component characterizing vector. The components are (1) number of cells; (2) number of empty squares; (3) number of regions; (4) optimality, whether the puzzle can be further emptied. The function generated by the SVM categorizes a fillomino puzzles into four difficulties similar to those of sudoku puzzles.

